{"meta":{"title":"Red Peregrine","subtitle":"Carl Scarlett's Blog","description":"Red Peregrine is the blog site of Carl Scarlett","author":"Carl Scarlett","url":"http://www.redperegrine.net"},"pages":[{"title":"Categories","date":"2017-12-16T06:44:09.363Z","updated":"2017-12-16T06:44:09.363Z","comments":true,"path":"categories/index.html","permalink":"http://www.redperegrine.net/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-16T06:44:14.003Z","updated":"2017-12-16T06:44:14.003Z","comments":true,"path":"tags/index.html","permalink":"http://www.redperegrine.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Changes of a Cosmic Scale","slug":"changing-everything","date":"2018-03-29T23:47:31.000Z","updated":"2018-03-30T00:55:00.073Z","comments":true,"path":"2018/03/30/changing-everything/","link":"","permalink":"http://www.redperegrine.net/2018/03/30/changing-everything/","excerpt":"I’ve reached a critical juncture in the development of my game and engine.","text":"I’ve reached a critical juncture in the development of my game and engine. I’ve been developing a game for the past 15 months. It’s been a labour of love, as any indie game developer can attest to. However, recently something happened that has forced me to pivot my roadmap significantly. Before I get to what’s happened I’d better give you some context, because I realise it is sorely lacking at this point. A Brief History of the ProjectOver two years ago I discovered how I could make the time to pursue my dream of developing (and releasing) a game. I’ve wanted to do this my whole life, and after several uncommitted attempts and a gap of at least 20 years since my last try I realised the passion to do this was burning as intensely as ever. What’s more, taking on a side project was going to save my sanity, as my 22+ year career as a programmer wasn’t letting me practice the skills I felt I needed. I love a good synergy, and here I could cover both issues by building a game. I chose to use the Microsoft .NET stack because the bulk of my developer experience is there, and the devices I owned (phone, desktop, laptop) were all in the Windows ecosystem. My laptop was a 128Gb Surface Pro 1 (bought the day they were available) and my phone a Nokia 930 running Windows 10. Both were in fantastic condition (both operationally and aesthetically) despite almost constant usage. However the Surface was so full of development tools and SDKs there was little free space for my project or other tools I would need. I only had very small daily periods to work on the project; my available time was daily train commutes to and from my day job. This started out as a 20 minute commute in the morning and the same in the evening, however along the way I did move house and this became two 30 minute windows that I currently enjoy. In terms of committing time to side projects this didn’t sound enough at first, and the disbelief I could be productive in such small bursts put me off for a long time. Being unable to find any other time I gave it a go, and two years later I’m amazed at how much I’ve achieved. asideI submitted a talk to present this development process at a developer conference last year but it didn’t get up unfortunately. It’s worth sharing the challenges and benefits of this process perhaps one day I’ll at least blog about it. As a consequence of the short periods of time available and being disconnected from the network while commuting, I chose not to start with an existing game engine as I felt it the learning curve require a heavy investment in online tutorials and other online research to be productive. So I decided to build the game engine on my own from scratch as well as the game itself. I know that sounds insane, but I didn’t rush into this decision blindly; I knew it would be super tough (and more than I could imagine), so I did quite a bit of experimentation and exploratory coding before I decided it really was achievable. I knew I would be happy with this decision as it would finally afford me the practical experiences I was craving (writing high performant, memory efficient code, and exploring previously unvisited areas of the .NET Framework), as well as allowing me to dump decades of mental pseudo-code into reality to see if my theories actually worked. Setting My Own ExpectationsGiven it would take a long time to build both an engine and a game from scratch under normal working circumstances, and that I only had 40 minutes a day (20 minute sprints), I had to be realistic about time. Most game developers and studios set themselves deadline/completion dates for their games, but that just wasn’t applicable for what I was doing and how I was working. I chose to not fix a date, but to fix the quality of the game at a high level and it would take “as long as it takes” to build. This meant I could commit to getting the design of the engine right from day one, focusing on performance, no memory leaks, and no blocking garbage collection when playing. The latter was the strongest in my mind, and I did a lot of further research to confirm what I believed was the best practice to avoid garbage collection in .NET (mostly declaring all memory use up front via object pooling). This lead to some satisfying conversations with people who were actively working on the .NET garbage collector at the time, the discovery of a memory profiling tool (BenchmarkDotNet), and a practice of regularly profiling the .NET framework to ensure my choice of code implementations in the engine code were optimal. I even blogged about that in my first blog post. Finally, I knew that if this worked it would be the beginning of a number of games I would produce. I wasn’t expecting to make any money from this first project (being on the Windows marketplace, which is a pretty small market compared to Apple and Google) so I expected to release the result for free, with some clever ideas for monetisation that didn’t change the game dynamics. The value I would get out of this project would be very personal: Practicing and developing the skills I felt were missing in my current skillset (personal skills growth) Keeping sane at work (not trying to force personal development into my day job as it just wasn’t happening) Getting years of game routines out of my head and into reality (overcoming impostor syndrome) Expanding my knowledge of game development terminology and practices (setting myself up for future game projects) Finding other game developers locally and on the web that I could talk to (establishing a new social network) Finding SupportI didn’t take that last point lightly. I knew what I was undertaking would require endurance as progress would be agonisingly slow. I back myself for mental toughness and sheer determination, but it would be foolish to take on such a project without support from others who knew what I was going through. So I reached out to the only game developer I knew (from a meetup he presented at once), who directed me to a local community called Let’s Make Games. I started attending Playup Perth where local developers were provided space playtesting their games for review and feedback. I exchanged Twitter handles with a few local developers and made a few connections. Social media then quickly expanded my network, and even revealed video content such as the excellent vlog Just Make Game by Armitage Games. Starting with MicrostepsMy first development task was to figure out was which rendering technology to use. I wrote several tests to trial Win2D which proved more than adequate. It works great as a performant renderer (siting astride DirectX) and also provides a game loop controller managing timing complexity for fixed timestep loops (and variable if you want it). It cohabits nicely with the Universal Windows Platform (UWP) which was my target language framework. Each new test I created established further confirmation that my stack integrated comfortably, allowing UWP gestures and touch and .NET sensor support (accelerometers and the like). An early test - UWP gestures with Win2D rendering These initial tests took some time but were important. I needed to be confident I wasn’t committing to a path leading to an impassible road block somewhere along the way. They also allowed to solidify my solution architecture while I explored the technology space. Another early test - testing the performance of sprite batches in Win2D As my tests grew in number and I learned more, the design for my game started to form in my mind. Resisting the urge to fully specify the design up front (who knew what I would discover along the way) I fleshed out about 70% of the design without committing to paper (for design agility). I now had my base game design and practical knowledge of the technology choices I could use to build my way there. My direction was established and it was time to start moving. One of the final tests - parallax clouds working across multiple devices with UWP The Zodman Project (#zodproj)After working on the project for several months my enthusiasm hadn’t waned and I had produced a surprising body of work (at least to me). Inspired by other indie devs in my social network, I decided to begin sharing my progress on social networks as well. At the time I didn’t have a blog, so I decided to use Twitter to give tweet-blogs about my work augmented by video. With a need to relate these tweets together I realised I needed a hashtag. I decided to label all my side projects under a single banner; The Zodman Project. Zodman is the nickname/handle that has stuck with me from my gaming days way back in the 1990s, and I’ve used it prolifically as an ID across the web for all this time (using ZodmanPerth when Zodman is already taken). The #zodproj hashtag would be used to group together all my online posts about my side projects and provide some context to individual posts. As a lover of coherent narrative, I felt it was important to start sharing progress from the beginning of the project, so my tweets started with those initial tests and proceeded in linear order. I wanted to show the body of work so far in weekly tweets until I caught up to where I was coding. I found this difficult because I had to find the time to create the video and also maintain my code so that the older tests continued to function while I coded at the bleeding edge of the project. This was particularly challenging as I continuously refactored my engine as I discovered better ways to do things. One other challenge was the size of a tweet which only allowed 140 at the time. While this was a blessing as it brutally focussed the scope of my posts (and let the video do the talking), I started getting that nagging feeling that maybe I should bite the bullet and start blogging as well. A Blog is BornFollowing a lengthy performance investigation with PerformanceDotNet, and having to augment the way it works to concatenate multiple runs into a single report, I finally had something to share that was beyond what Twitter could suitably accommodate. It was time to get my own blog. After scouring the web for ready-made blog services, worrying about loss of IP/data and control over layout and style, I settled on source controlled static site generation and managing deployment and hosting myself. Hexo is a static site generator that suits my commute-working style. Posts are markdown which I edit using VS Code and suits source control. It includes a local node server for testing the site locally prior to deployment. I then deploy to GitHub pages which provides hosting for a single, free, size-limited static website per account. After paying for a DNS entry and routing requests to Github, my blog was online. I had finally created an environment to share ideas in depth the opportunity to start a game blog. However, I struggled to create the time necessary to create blog posts. It takes some time to create posts, especially when you haven’t blogged in a while and you’ve got a lot of ground to cover. I found I wasn’t blogging because of the time required, and all the time I had available went into developing the things I wanted to blog about; Catch 22. Still, at least I was pushing my game and engine forward so I could be happy with that. I resigned myself to remain uncomfortable with falling behind in sharing my journey until I had some time to reflect on resolving the issue. Upgrading my Development EnvironmentEven though things were going pretty well with development I was starting to really feel the lack of disk space was starting to hamper progress. I had been eyeing off the new Surface Pro (2017 edition, 5th generation) with envy, and when my wife’s laptop finally died it was the perfect time to change up and gift her my Surface Pro 1 (a major step up from her awful laptop at least). I went for the basic I5 with 8Gb RAM and 256Gb disk space. I went for extra disk because of my troubles with space in the past. I expected this device would last me for the next 5 years or more, and the knowledge that in that time I would start using pre-built game engines and other tooling that would eat into the free space. The development experience on the new machine wasn’t too different to the 1st generation to be honest, though the additional screen resolution and CPU power made a noticeable difference. The new screen doesn’t handle being in daylight on the train as well though, and I had to purchase a polarised screen protector because when I was wearing my sunglasses I couldn’t read the screen! The screen brightness isn’t as bright either and I still find it a little difficult to read. I must say though that it’s well worth buying the new Surface Pen and nib set. The tilt control allows you to sketch with a feel almost like using a real pencil and I can’t wait to do some art with it when I can find the time. The Game ChangerAnd then it happened…the big whopper; the event that would change everything. Microsoft had released a Windows 10 update that stopped my phone from working properly. First I noticed that my Twitter app stopped scrolling after displaying about 20 posts. This was annoying as every spare moment I had would be spent looking through my feed to stay motivated by the indie dev network. I was missing out on a lot of great content and motivation. Then I noticed my email wasn’t working to well either. I could no longer email research findings to myself for review on a desktop sometime later. The loss of this functionality made things a bit too much to bear. I had encountered similar issues with a prior phone update, but not for such an extended period. The phone partially installs the new update (causing software quirks) but it fails and tries again at the next opportunity (my settings say to try nightly). I waited several weeks before I decided a successful update may not be coming anytime soon. My phone version was out of support with Microsoft so they were under no obligation to correct the issue. I had no idea when the next update would come, or if it would resolve the issue; there were no guarantees the next update would not have similar issues. The platform I was targeting was now unstable and I was forced to reconsider the approach I was taking. Without a stable platform there was no guarantee that the limited customer base that existed would still be there if I got up and running again and managed to finish my game in reasonable time. I had a difficult choice to make. I was weighing up years of lost learning opportunities through developing the engine myself to move forward on an existing game engine that target a set of devices I didn’t own. While it took some soul searching the way forward was inconvenient yet obvious; I had to change platforms sooner than anticipated and target the Apple and/or Android market. The event was literally a game changer. Not a Total LossAs sad as it was, the change did not mean I had wasted a year of development. Let’s look again at the list of things I wanted to achieve: Practicing and developing the skills I felt were missing in my current skillset (personal skills growth) - SuccessI learned a great deal about .NET Garbage Collection, memory management, object pooling, and using arrays in anger. My most recent refactor of the game engine (which was incomplete at the time where “the event” happened), was further proof to myself that I had an excellent handle on solution architecture and that I knew how to make the choices that would benefit working with and extending the engine. Keeping sane at work (not trying to force personal development into my day job as it just wasn’t happening) - SuccessI was a lot happier at work as I was no longer frustrated that opportunities to learn in areas I felt I was lacking never came. I was managing that progress on my own time, and at work I could focus on doing work to the best of my ability and having more fun. Getting years of game routines out of my head and into reality (overcoming impostor syndrome) - SuccessRoutines such as tile maps, sprite batching, user input without compromising architecture, were amazingly cathartic to get out of my head and seeing in real life. The most enjoyable of all though was writing my own collision detection in pure geometry, not only because maths is awesome but because I love explore areas of mathematics I have never seen before. I had expanded my horizons and in doing so blew away any reason to call myself an impostor. Expanding my knowledge of game development terminology and practices (setting myself up for future game projects) - SuccessBecause I worked as close to the metal as my framework choice allowed without fighting the language framework, I was exposed to the gnarly detail of the areas of game development I felt I needed. When I saw people using existing game engines such as Unity and Unreal and had glimpses of how they were structured, it confirmed to me I was doing things right and learning all the right things. Finding other game developers locally and on the web that I could talk to (establishing a new social network) - SuccessI could never have come this far if I were truly alone. While it’s been a disappointing year for socialising with local indie devs, I’ve developed relationships both in my own country and beyond. Though these relationships are new, they give me confidence that I belong among such a group of inspirational and talented people who understand what I’m going through and can support me when I’m feeling down. The Do-OverOverall my effort over the previous year has born substantial fruit and despite my sadness at the passing of an old friend (Windows Phone as a development platform) it can only be called a success. I now have a new direction to move in with purpose, with the benefit of it being a more densely populated market of people to potentially see my wares. Given I no longer need to write a game engine myself, I anticipate my game will evolve more rapidly as I am liberated to focus solely on that. This should go a long way to making me feel a lot closer to the cadence at which other indie devs work, despite still only having two half-hour sprints a day available to devote. I’m hoping more rapid progress will translate into more rapid sharing of screenshots etc, and in doing so any self doubt about being an impostor will be much more infrequent. I’ve been given a second chance to do things right so it’s important I reflect on the journey so far, reinforce what I’ve learned to myself and to consider how to be more effective this time around. The most obvious place to improve is where I have been feeling the most angst; socialising my work. Doing it BetterThrough my effort with social media so far I have discovered which channels are good for different sizes of communication and the frequency that works best on them. Where I have been previously frustrated by my inability to devote time and been blocked because I hadn’t established a channel, I now have a better understanding on how to do it better this time. This means: TwitterThis channel will be used to report up to the minute stuff without context, because the frequent flow of tweets itself creates the context which readers can follow (pun unintended). It should also be used to participate in community groups such as #screenshotsaturday. I will continue to use #zodproj to flag my game tweets and aim to post more often and only with up-to-date information. Game BlogNow that I have created a space to blog I will use it more frequently. I’ve learned that while it is a good channel when you have more words than can be squeezed into a single tweet, it takes far too long to write posts if you leave it too long. Just as frequent releases of software makes deploying releases easier, I’m believe more frequent posts will make blogging easier. Perhaps whenever I pass a major milestone in my development, or perhaps when I’ve passed a few minor ones, I’ll do a quick post so they don’t take too long to write. I’m looking for a sweet spot between creating my game and blogging about it. I hope that now I’ll be using a pre-built, rich featured game engine I can focus on building the game itself, which will create a more satisfying timeline of progress and I won’t feel guilty about taking my limited time away to work on blog posts. Final thoughtsBecause of the limited time I have available it’s taken me two weeks of actual time going by to create this post. In that time I have purchased, received, and set up a new Android phone, been researching game engines for suitability to my development practices, and started learning about one in particular in more detail. I can see I’ve got a long road of discovery ahead before I get back to being as productive as I was, but I believe this effort will rapidly increase the speed at which I deliver and I will be more creative as a result. I look forward to posting more frequent updates in the future.","categories":[{"name":"indiedev","slug":"indiedev","permalink":"http://www.redperegrine.net/categories/indiedev/"},{"name":"gameengine","slug":"indiedev/gameengine","permalink":"http://www.redperegrine.net/categories/indiedev/gameengine/"},{"name":"zodproj","slug":"zodproj","permalink":"http://www.redperegrine.net/categories/zodproj/"}],"tags":[{"name":"gameblog","slug":"gameblog","permalink":"http://www.redperegrine.net/tags/gameblog/"}]},{"title":"Measuring C# Performance with BenchmarkDotNet","slug":"measuring-csharp-perf-with-benchmarkdotnet","date":"2017-12-23T09:12:47.000Z","updated":"2018-03-29T10:17:41.180Z","comments":true,"path":"2017/12/23/measuring-csharp-perf-with-benchmarkdotnet/","link":"","permalink":"http://www.redperegrine.net/2017/12/23/measuring-csharp-perf-with-benchmarkdotnet/","excerpt":"I’m measuring optimal C# code implementations for a game engine I’m building.","text":"I’m measuring optimal C# code implementations for a game engine I’m building. BackgroundI recently took on a “little side project” to pursue a lifelong dream: designing, creating (and releasing!) a computer game. Though I’ve had the desire to do this for more than three and a half decades, I never quite got around to making a consistent, concerted effort. It’s not because I’m lazy, I’ve just managed to pack a whole bunch of experiences into my life so far and, until recently, couldn’t find enough time to devote to the cause. By “little side project” I’m being a sarcastic of course. I knew when I started this journey that building a game is no trivial feat, and there would be unknown unknowns that would arise and need to be dealt with along the way. That discovery was part of the exciting thing for me because I love learning new things. However, because I really enjoy a challenge (and from the necessity of my circumstances), I made the decision to write the game engine as well; from scratch. Fortunately I’d pursued life experiences that included all the ingredients I would need to pull off such a feat from both a creative and practical standpoint, including a lengthy career in software engineering and commercial experience in UX design. I’ll explore the circumstances that drove those initial decisions another time. Right now, it’s enough to know that the game engine is written in C# on UWP using Win2D, and targets Windows tablets and phones that have accelerometer sensors and touch screens. The game is a top-down 2D space shoot ‘em up with a retro arcade look. Build A Game Engine in C#…Are You Crazy?When people talk of building game engines, C# and .NET aren’t terribly popular choices. The .NET framework, while a much loved and carefully crafted platform, hasn’t exactly been built for the demands of a high-performing game engine in mind. I don’t think my engine will be too demanding though, so using .NET is a feasible option. Win2D is a powerful ally here, being a finely tuned wrapper over DirectX that is built for performance. Win2D also provides a game-loop that gracefully handles the complexity of loop timing management, so that’s one less thing I needed to worry about. This leaves the game engine “merely” doing some user input handling, physics, collision detections, game logic, and image rendering. What could go wrong right? As long as I build with the Garbage Collector in mind, and execute code in tight enough loops, I would hopefully get a smooth 60 frames per second across my target devices. This is a nice engineering challenge that will keep me happily satisfying my inner geek for some time. Performance Front and CentreI was reasonably sure I could make something decent with my technology choices, and a few test applications later I committed to the task ahead. With a freshly read copy of Bob Nystrom’s amazing eBook Game Programming Patterns up my sleeve, years of mentally constructed game systems and designs that were eager to escape my mind, and the skills I had nurtured over my career, I figured I had a decent shot at a solid result. But confidence alone was never going to be enough. Going into development of the engine I knew I would have to make every nanosecond count. While the architecture was wholly under my control and I trusted my skills, there was one concern that still hung heavy on my mind; would the .NET Framework itself be performant enough? There was only one way to know for sure; I was going to have to write performance tests for the framework itself. And when you want to know the performance of .NET code I know of nothing more suited to the task than BenchmarkDotNet. BenchmarkDotNet and LINQPadI’m a heavy LINQPad user from way back. Among other things, LINQPad enables me to test hypotheses quickly away from the complexity of my larger code bases. Once I’m happy, I move the validated code into the main codebase and do some manual integration tests. This process works really well for me, so when I found myself needing to test different C# implementation patterns in isolation, LINQPad was a natural choice. Fortunately for me my timing was just right; BenchmarkDotNet had just added support for running inside LINQPad, and LINQPad had just added support for hosting BenchmarkDotNet. While the road since has been a little bumpy, the state of both tools was good enough to provide what I needed. Testing Different Iterator Patterns in .NETI really enjoyed writing my own collision detection system; it’s the kind of challenge I relish. My starting point was an excellent tutorial by Nilson Suoto called Collision Detection for Solid Objects, and after a lot of experimentation I had a really tight system. I had a Sort and Sweep service using cheap AABB checks to find collections of objects with potential collisions (the broad phase), which were used to discover the actual collisions using Minkowski Sums and Convex Hulls of object geometries (the narrow phase). We’re not covering the details of the implementation here, but you should know the narrow phase contains expensive CPU operations and I’ve spent an appropriate amount of time optimising the hell out of them. Codewise, the Collision Detection system drives the Sort and Sweep service using an iterator pattern. You probably know this pattern from implementing IEnumerable&lt;T&gt;; GetEnumerator() methods that yield appropriate results. This is how I implemented it at first, and it made for some nice, readable code. However, I had a hunch that this generic interface may not be the most performant way to drive the service, so I devised a plan to test different implementations of the iterator pattern to see if I could find time savings. I also had concerns that the use of generics would add pressure to the .NET Garbage Collector, and as such I was interested in verifying this measuring memory aspects of each implementation as well. Initial BenchmarksSwitching to LINQPad, I wrote up a Worker class to simulate the Collision Detection system doing expensive work by summing the values yielded by a Driver class, which represented the Sort And Sweep service. Main() simply called the benchmark runner to run with the Worker type. I marked up the Worker with a MemoryDiagnoser to report on memory consumption, and because of my cross device intentions I thought it’s prudent to explore 32bit and 64bit generated code. The code looked a little like this: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[MemoryDiagnoser][RyuJitX64Job, LegacyJitX86Job]public class Worker&#123; [Benchmark] public void NormalEnumerator() &#123; Driver driver = new Driver(); int count = 0; int sum = 0; foreach (int i in driver) &#123; sum += i; count++; &#125; &#125;&#125;class Driver : IEnumerable&lt;int&gt;&#123; const int _size = 10; int[] _array; public Driver() &#123; _array = new int[_size]; for (int i = 0; i &lt; _size; i++) _array[i] = 1; &#125; public IEnumerator&lt;int&gt; GetEnumerator() &#123; for (int i = 0; i &lt; _size; i++) yield return _array[i]; &#125; IEnumerator IEnumerable.GetEnumerator() &#123; return GetEnumerator(); &#125;&#125;void Main()&#123; BenchmarkRunner.Run&lt;Worker&gt;();&#125; As well as the usual output appearing in LINQPad’s results window, running this produced a nice set of reports in various file formats in the subfolder \\BenchmarkDotNet.Artifacts\\results where LINQPad was executing. NoteYou will probably need to run LINQPad as an admin to get it to work. Here’s an extract from a report running this code: From this I was able to reason a few things about a single implementation of an iterator pattern on a small sample size of 10 items. This was a good start and served as proof that the concept of measuring performance in this way worked. Many Rivers to CrossThinking ahead, I knew I had challenges to face. First, an array size of 10 probably wasn’t representative of how big the object arrays would end up in my game. I wasn’t sure how many objects I would need, but I knew performance rarely scales linearly. I wanted to test the same implementations of iterator patterns on array sizes with various orders of magnitude. Unfortunately BenchmarkDotNet didn’t support marking up benchmark methods with injectable parameters (array size in this case), so I had to roll my own solution. Second, while I knew I could have different implementations inside a single Worker, I would need to be careful not to let the sharing of code scope compromise what I was measuring; the implementations could not affect one another. Third, the way I simulated actual work in the implementations had to correctly represent code in my original code base that hadn’t been written yet! Without attention to this detail it would be easy for my abstraction to stray from what would be reality, influencing the implementation and not representing a realistic scenario. Fourth, the implementation code should be reasonably easy to read. I would need to discover where the line was between performance and readability while I thought of innovative implementations. Fifth, I wanted to explore iterators over different kinds of objects such as value types, reference types, and generic types. The result would guide the object structure forming the basis of my collision detection system. Finally, I wanted all these tests to run on a single execution run and roll into a single report table. I figured I would use Excel for final analysis so it would be best if the results were automatically collected together so I didn’t have to do any manual amalgamations every time I completed a test run and wanted explored the results. The Usual Black-Box ChallengesI very quickly discovered that when I performed multiple tests over a single Worker type within the same run, the naming convention BenchmarkDotNet used to create the filenames would result in the overwrite of previous reports. I created a helper class to create backups of report files on disk and track the generated file names. I then added amalgamation of the final report using these backup files using AngleSharp (an open source HTML parser) to rip apart the tables in these files and create my own HTML report. Along the way I also discovered that LINQPad’s Dump() methods weren’t available when BenchmarkDotNet was running, and would cause a terminating exception. This hampered my ability to verify that iterator implementations were working properly (i.e. actually iterating), so I added a “runmode” state to the helper class that allowed me to switch between manual verification of code (where code is executed using LINQPad and not via BenchmarkDotNet) and producing the benchmark reports (where BenchmarkDotNet controlled the execution and not LINQPad). The “runmode” also let me avoid throwing exceptions by isolating calls to Dump() behind conditional checks. Finally, I created a state machine that looped through the various implementations, changing the size of the array each time. The state of the machine was another addition to the helper class. The report backup system hooked into this state to generate unique report names, which were used in turn to create the column values in the amalgamated report. Different Implementations to TestI thought of 4 different iterator implementations to try out: NormalEnumeratorThis was the IEnumerable&lt;T&gt; implementation I already had using GetEnumerator() methods and yield to return results at appropriate points. HandCrankedEnumeratorThis implementation is a POCO with Reset() and MoveNext() methods and an EOF property for controlling the loop. Would removing a broad, generic implementation improve performance and reduce memory usage? HandCrankedWithMoveNextStateThis a variation of the previous implementation that eliminated the EOF and returned feedback from Reset() and MoveNext(). This reduced the number of statements required to drive the iterator which I suspected would translate into better performance. ResultSetFullyCalculatedThis avoided iterating altogether, replacing it with a big synchronous operation calculating all the results in one pass and exposing a Results array. Obviously this would have higher memory requirements, but would it perform better? NoteMy game engine runs on a single thread. Multi-threaded concerns such as the timing of the read and write of values from different threads did not need to be considered. Here’s a gist containing a copy of the final LINQPad code: Amalgamated ReportOnce I was sure all the implementations were working correctly I switched on all the benchmarking options I wanted, plugged in some array sizes, and let it run. On my Surface Pro with an i5 processor this took about 42 minutes, but was worth the wait because the data is rich and dense. Here’s the amalgamated report from one such run. If you’re used to the usual output columns BenchmarkDotNet produces you’ll recognise where I’ve inserted the other relevant data. The Type and Size columns correspond to the type of Worker (IntegerWorker for value type tests, ItemWorker for reference type tests, and GenericWorkder for generic type tests), and the size of the array used to produce the result. The other columns come straight from the BenchmarkDotNet reports. Analysing with ExcelWith all the data is in one place I wanted to use Excel’s analysis tools to help me compare the results and derive conclusions. Copy and paste as text did the trick, though I did have to strip the alphabetical characters from the numeric columns and change their cell format to a number. Once that was done I used a red-green colour scale conditional formatting on the numeric data to create a performance heat map, and used table filters and sorting to do the analysis. Here’s the same amalgamated report formatted this way in Excel: Looking at the Mean column there was an obvious candidate for being too slow; the red cells. Turns out the NormalEnumerator method (the implementation I was already using) was the worst performing, taking almost twice as long as the other methods. I filtered that method out and dug deeper. When I looked at the fasted results in each Size group (those with the greenest Mean values), I could see that the ResultSetFullyCalculated method looked suspiciously slow. I checked each ResultSetFullyCalculated method against the other methods in the same Size group by eye and confirmed it; calculating the results in one hit was slower than flowing back and forth between the Worker and the Driver. asideThis was a pleasant surprise. I had expected a higher memory footprint and a lower execution time. This kind of result is exactly why you need to validate early; it’s much cheaper to build things right the “first time” instead of trying to refactor once you’ve built a whole bunch of stuff on top of a false assumption. I had a real Adam Savage moment with this finding. Science! Let’s filter out the ResultSetFullyCalculated method and keep digging. Now we get down to the pointy end of the analysis. With only two methods remaining to compare against each other, there’s nothing much to do but check each pair individually. The results are really close, and difficult to compare due to the variance in Error and StdDev. However the HandCrankedEnumerator is marginally faster in almost every pair. This was a bit of a surprise given I had assumed less statements in the caller would mean less execution time, but without checking the final generated code you can never be sure how such assumptions pan out. The performance difference isn’t significant enough for me to take my investigation that far, so I’ll happily settle on the variant that’s easier to read, maintain, and is generally faster. How Bad is Your Memory?Did you notice I haven’t talked at all about the memory usage by any of the implementations? Well, throughout my analysis I was giving them the occasional, cursory glance. The fact is, there wasn’t anything significant to worry about. There was only very small Gen 0 in all implementations apart from NormalEnumerator, which was always the highest memory user in each group and always puts the most pressure on the Garbage Collector. The general rule of thumb I’ll be taking forward is that for balancing performance and memory concerns, always go with a POCO. Of course, when it counts I’ll still be testing assumptions of course! SummaryIn the end, because of my findings, I refactored my Sort and Sweep service to be a POCO with Reset() and MoveNext() methods and an EOF property for controlling the loop as per the HandCrankedEnumerator test implementation. It really didn’t take long to convert it over, and I now feel confident and satisfied that through my due diligence I’ve squeezed a little more performance out of a crucial game subsystem. Onward and upward!","categories":[{"name":"indiedev","slug":"indiedev","permalink":"http://www.redperegrine.net/categories/indiedev/"},{"name":"gameengine","slug":"indiedev/gameengine","permalink":"http://www.redperegrine.net/categories/indiedev/gameengine/"},{"name":"tests","slug":"tests","permalink":"http://www.redperegrine.net/categories/tests/"},{"name":"performance","slug":"tests/performance","permalink":"http://www.redperegrine.net/categories/tests/performance/"}],"tags":[{"name":"BenchmarkDotNet","slug":"BenchmarkDotNet","permalink":"http://www.redperegrine.net/tags/BenchmarkDotNet/"},{"name":"LINQPad","slug":"LINQPad","permalink":"http://www.redperegrine.net/tags/LINQPad/"},{"name":"C#","slug":"C","permalink":"http://www.redperegrine.net/tags/C/"},{"name":"Win2d","slug":"Win2d","permalink":"http://www.redperegrine.net/tags/Win2d/"}]}]}